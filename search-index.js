var N = null;var searchIndex = {};
searchIndex["futures_borrow"]={"doc":"Futures-aware borrow cell.","items":[[3,"Borrow","futures_borrow","A mutable memory location with future-aware dynamically checked borrow rules.",N,N],[3,"BorrowGuard","","Holds a borrowed value obtained from `Borrow`.",N,N],[3,"BorrowError","","Error produced by a failed `poll_borrow` call.",N,N],[3,"TryBorrowError","","Error produced by a failed `try_borrow` call.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Borrow` containing `value`.",2,[[["t"]],["borrow"]]],[11,"is_ready","","Returns `true` if the value is not already borrowed.",2,[[["self"]],["bool"]]],[11,"poll_ready","","Returns `Ready` when the value is not already borrowed.",2,[[["self"]],["poll",["borrowerror"]]]],[11,"poll_borrow","","Attempt to borrow the value, returning `NotReady` if it cannot be borrowed.",2,[[["self"]],["poll",["borrowguard","borrowerror"]]]],[11,"try_borrow","","Attempt to borrow the value, returning `Err` if it cannot be borrowed.",2,[[["self"]],["result",["borrowguard","tryborrowerror"]]]],[11,"map","","Make a new `BorrowGuard` for a component of the borrowed data.",2,[[["borrowguard"],["f"]],["borrowguard"]]],[11,"try_map","","Make a new `BorrowGuard` for a component of the borrowed data.",2,[[["borrowguard"],["f"]],["result",["borrowguard"]]]],[11,"default","","",2,[[],["borrow"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"deref","","",3,[[["self"]],["t"]]],[11,"deref_mut","","",3,[[["self"]],["t"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"is_poisoned","","",1,[[["self"]],["bool"]]]],"paths":[[3,"BorrowError"],[3,"TryBorrowError"],[3,"Borrow"],[3,"BorrowGuard"]]};
searchIndex["futures_test"]={"doc":"","items":[[0,"harness","futures_test","",N,N],[3,"Harness","futures_test::harness","Wraps a future, providing an API to interact with it while off task.",N,N],[3,"TimeoutError","","Error produced by `TestHarness` operations with timeout.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","Wraps `obj` in a test harness, enabling interacting with the future while not on a `Task`.",0,[[["t"]],["self"]]],[11,"with","","",0,[[["self"],["f"]],["r"]]],[11,"is_notified","","Returns `true` if the inner future has received a readiness notification since the last action has been performed.",0,[[["self"]],["bool"]]],[11,"get_ref","","Returns a reference to the inner future.",0,[[["self"]],["t"]]],[11,"get_mut","","Returns a mutable reference to the inner future.",0,[[["self"]],["t"]]],[11,"into_inner","","Consumes `self`, returning the inner future.",0,[[["self"]],["t"]]],[11,"poll_fn","","Wraps the `poll_fn` in a harness.",0,[[["f"]],["self"]]],[11,"poll","","Polls the inner future.",0,[[["self"]],["poll"]]],[11,"wait","","Waits for the internal future to complete, blocking this thread's execution until it does.",0,[[["self"]],["result"]]],[11,"wait_timeout","","Waits for the internal future to complete, blocking this thread's execution for at most `dur`.",0,[[["self"],["duration"]],["result",["timeouterror"]]]],[11,"poll_next","","Polls the inner future.",0,[[["self"]],["poll",["option"]]]],[11,"is_timeout","","",1,[[["self"]],["bool"]]],[11,"into_inner","","Consumes `self`, returning the inner error. Returns `None` if `self` represents a timeout.",1,[[["self"]],["option"]]]],"paths":[[3,"Harness"],[3,"TimeoutError"]]};
searchIndex["futures_watch"]={"doc":"A multi-consumer, single producer cell that receives notifications when the inner value is changed.","items":[[3,"Watch","futures_watch","A future-aware cell that receives notifications when the inner value is changed.",N,N],[3,"Store","","Update the inner value of a `Watch` cell.",N,N],[3,"Ref","","Borrowed reference",N,N],[3,"WatchError","","Errors produced by `Watch`.",N,N],[3,"StoreError","","Errors produced by `Store`.",N,N],[0,"then_stream","","Uses a `Watch` to produce a `Stream` of mapped values.",N,N],[3,"ThenStream","futures_watch::then_stream","Each time the underlying `Watch<T>` is updated, the stream maps over the most-recent value.",N,N],[8,"Then","","Maps borrowed references to `T` into an `Item`.",N,N],[16,"Output","","The output type.",0,N],[16,"Error","","What you get when Map fails.",0,N],[10,"then","","Produces a new Output value.",0,[[["self"],["result",["watcherror"]]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"poll","","",1,[[["self"]],["poll",["option"]]]],[11,"clone","","",1,[[["self"]],["self"]]],[11,"fmt","futures_watch","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new watch cell, returning the consumer / producer halves.",2,N],[11,"is_final","","Returns true if the current value represents the final value",2,[[["self"]],["bool"]]],[11,"borrow","","Returns a reference to the inner value",2,[[["self"]],["ref"]]],[11,"then_stream","","Convert this watch into a stream of values produced by an `M`-typed map function.",2,[[["self"],["m"]],["thenstream"]]],[11,"poll","","",2,[[["self"]],["poll",["option"]]]],[11,"clone","","",2,[[["self"]],["self"]]],[11,"drop","","",2,[[["self"]]]],[11,"store","","Store a new value in the cell, notifying all watchers. The previous value is returned.",3,[[["self"],["t"]],["result",["storeerror"]]]],[11,"poll_cancel","","Returns `Ready` when all watchers have dropped.",3,[[["self"]],["poll"]]],[11,"start_send","","",3,[[["self"],["t"]],["startsend",["storeerror"]]]],[11,"poll_complete","","",3,[[["self"]],["poll",["storeerror"]]]],[11,"drop","","",3,[[["self"]]]],[11,"deref","","",4,[[["self"]],["t"]]]],"paths":[[8,"Then"],[3,"ThenStream"],[3,"Watch"],[3,"Store"],[3,"Ref"],[3,"WatchError"],[3,"StoreError"]]};
initSearch(searchIndex);
